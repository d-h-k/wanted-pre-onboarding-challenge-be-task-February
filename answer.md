# 백엔드 푸리온보딩 about MySQL
- 해당 답변은 구글링 결과와 ChatGPT 의 답변을 바탕으로 작성하였습니다. 

## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 제 답변전략은 아래 순서로 정하고 싶습니다 
  - 1-1 데이터베이스
  - 1-2 관계형의 의미
  - 1-3 비관계형 데이터베이스
  - 1-4 장단점 비교와 Best Pratice

#### 1-1 데이터베이스
- 데이터베이스 설명 전에 생략된 단어를 전부 풀어서 쓰면 `데이터베이스 소프트웨어 프로덕트` 라고 생각합니다. 
- 데이터를 Create, Read, Write, Delete 할수 있는 소프트웨어는 모두 데이터 베이스(소프트웨어 프로덕트)입니다. 

#### 1-2 관계형의 의미

- 관계형(relational)은 데이터가 구성되고 서로 관련되는 방식인데요. 데이터끼리 관계가 있어서 관계형입니다
- 관계형 데이터베이스에서 데이터는 스프레드시트와 유사하게 행과 열이 있는 테이블로 구성됩니다. 이러한 테이블의 데이터 간의 관계는 서로 다른 테이블의 관련 데이터 간의 포인터 역할을 하는 키를 사용하여 설정됩니다.
- 예를 들어 도서관의 데이터베이스에는 책에 대한 테이블 하나와 저자에 대한 다른 테이블이 있을 수 있습니다. 두 테이블 간의 관계는 고유한 저자 ID를 통해 설정할 수 있습니다. 이 ID는 두 테이블 모두에 나타나며 데이터베이스가 각 저자와 책을 연결할 수 있도록 합니다.
- 데이터베이스에서 데이터를 구성하고 관련시키는 이러한 접근 방식은 복잡한 데이터 구조 및 관계를 모델링하는 강력하고 유연한 방법을 제공하며 많은 애플리케이션에서 가장 널리 사용되는 데이터베이스 모델이 되었습니다.

#### 1-3 비관계형 데이터베이스 

- 관계형/비관계형은 data structure 에 따른 분류입니다.
- 비관계형 데이터베이스는 관계형 데이터베이스가 아닌 다른 모든 데이터베이스를 묶어서 부르는 이름인데여
- 관계형 모델을 사용하지는 않는데, 이런 비관계형 데이터베이스의 일반적인 유형은 다음과 같습니다.
  - Document : 데이터를 JSON 또는 XML 같은 문서로 저장
  - Key-Value : 데이터를 키-값 쌍의 모음으로 저장
  - Column-family : 데이터를 행이 아닌 열 모음으로 저장
  - Graph : 데이터를 노드와 에지로 저장
  - Time-series

#### 1-4 장단점 비교와 Best Pratice

- 앞에서 제시한대로 관계형/비관계형은 data structure(자료구조) 에 관한 이야기이므로, 

|종류|장점|단점|함께해서 좋은곳
|------|---|---|---|
|relational|CRUD 모든 방면에서 적당한 성능, 트랜잭션|scale-out 어려움, 관계가 정해져있기 때문에 유연하지않고, 서비스가 고도화되면서 필연적이로 관계가 복잡해짐| 데이터 정규화가 강제된다는게 장점이자 단점. 대부분의 OLTP 서비스
|Document|정규화를 하지않는게 장점이자 단점, scale-out적당 |트랜잭션 곤란, ACID 제한적 | json, 정규화하기 힘든 텍스트데이터
|Key-Value | Map자료구조라서 모델이 단순, CRUD 모두 빠름 | 보조인덱스 활용 불가능, Key가 유일한 검색조건 |
|Column-family  | 수평확장이 가능, 통계 등 대용량 데이터에서 인사이트를 얻을때 유리 | 아무리 적게잡아도 최소 천만건 이상부터 쓸만해서 대부분의 경우에 일로 만난사이라는게 단점 | 관계형 대이터베이스의 complementarity 한 관계임 >> 비슷한거같은데 완전 반대라서 상호보완적임..?
|Graph |  |  | 안써봐서 모르고 찾아봐도 모르겠습니다
|Time-series  |  |  | 센서값 같이 시간에 따라 변화하는 추이를 볼때 적당함 : 네비앱의 GPS raw data






-----------------------

## 2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 여러단계의 작업들을 하나의 동작으로 묶어주는 기능입니다. 
- 하나의 트랜잭션 내부에서는 내부의 여러 단계의 작업중 하나가  실패하더라도 트랜잭션 전체를 실패로 인식하기 때문에 데이터베이스가 일관된 상태를 유지할수 있습니다.
- 데이터베이스 작업이 특정 순서로 실행되어야 할때 순서를 보장하기도 하며, 모든 작업이 성공하거나 모든 작업이 실패할수 있도록 묶어줍니다.
- 트랜잭션에서 성능-데이터 안정성 사이의 Tread-off 수준을 결정하는 전략으로 `isolation level`, `optimistic and pessimistic locking`이 있습니다




-----------------------

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인은 관련 열을 기반으로 여러 테이블의 데이터를 결합하는 기능입니다.
- SQL에서 조인의 역할은 마치 단일 테이블인 것처럼 여러 테이블에서 데이터를 검색할 수 있도록 해줍니다.
- 조인 방법은 아래와 같습니다
  - INNER JOIN
    - : 두 테이블 모두 일치하는 행만 반환합니다. 두 테이블에서 일치하는 값이 있는 행만 반환합니다.
  - LEFT JOIN(또는 LEFT OUTER JOIN)
    - : 왼쪽 테이블(table1)의 모든 행과 오른쪽 테이블(table2)의 일치하는 행을 반환합니다. 결과에는 오른쪽에서 일치하지 않는 행에 대한 NULL 값이 포함됩니다.
  - RIGHT JOIN(또는 RIGHT OUTER JOIN)
    - : 오른쪽 테이블(table2)의 모든 행과 왼쪽 테이블(table1)의 일치하는 행을 반환합니다. 결과에는 왼쪽에서 일치하지 않는 행에 대한 NULL 값이 포함됩니다.
  - FULL OUTER JOIN
    - : 결합된 일치하는 행과 NULL 값을 포함하는 일치하지 않는 행을 포함하여 두 테이블의 모든 행을 반환합니다.
  - CROSS JOIN
    - : 두 테이블의 데카르트 곱을 반환합니다. 즉, 두 테이블에서 가능한 모든 행 조합을 반환합니다.
  - SELF JOIN
    - : 자기 테이블 자신과 조인되는 조인.


#### INNER JOIN:

```SQL
SELECT *
FROM table1
INNER JOIN table2
ON table1.column = table2.column;
```

#### LEFT JOIN:

```SQL
SELECT *
FROM table1
LEFT JOIN table2
ON table1.column = table2.column;
```

#### RIGHT JOIN:

```SQL
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.column = table2.column;
```

#### FULL OUTER JOIN:

```SQL
SELECT *
FROM table1
FULL OUTER JOIN table2
ON table1.column = table2.column;
```

#### CROSS JOIN:

```SQL
SELECT *
FROM table1
CROSS JOIN table2;
```

#### SELF JOIN:

```SQL
SELECT *
FROM table1 t1
JOIN table1 t2
ON t1.column = t2.column;
```



-----------------------

## 4. MySQL에서 인덱스(index)란 무엇인가요?
- 인덱스란 데이터중 일부만 떼어내서 한번더 저장한 추가 데이터
  - 검색속도 향상을 위해서 존재합니다.
  - Write 기능(INSERT, UPDATE, DELETE) 의 성능이 하락합니다. 
  - Read 기능의 (SELECT) 성능을 높이는 기법
- 보조인덱스
  - 
- 주인덱스
- 클러스터드 인덱스
